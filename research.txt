Анализ современных исследований, посвящённых сравнительной оценке REST, gRPC и GraphQL в микросервисной архитектуре, показывает, что в последние годы акцент смещается от теоретических описаний к экспериментальным бенчмаркам. Наиболее детализированная работа данного направления — исследование Niswar et al. (2024), в котором авторы провели нагрузочное тестирование трёх микросервисов (Go + MySQL + Redis) при различной интенсивности запросов.

Согласно этим данным, gRPC стабильно демонстрирует минимальную латентность: при нагрузке от 100 до 500 параллельных запросов время отклика для простых структур данных находилось в диапазоне 233–2606 мс, что оказалось в 3–5 раз быстрее REST и в 10–20 раз быстрее GraphQL, где замеры достигали 3852–21148 мс. При этом интересно, что для сложных вложенных структур REST в ряде случаев показывал результаты, сопоставимые с gRPC, а иногда и превосходил его (например, диапазон 5201–16646 мс против 5667–14962 мс у gRPC), что авторы объясняют спецификой последовательных чтений и характером запросов к базе данных.

Не менее показательны результаты по нагрузке на процессор: REST в тестах Niswar et al. потреблял 10–49 % CPU, gRPC — 11–36 %, тогда как GraphQL в аналогичных условиях загружал процессор на 120–142 % для простых данных и до 177 % — для сложных. Эти различия подчёркивают, что GraphQL предоставляет гибкость выборки ценой существенно более тяжёлой серверной обработки.

Сопоставив результаты Niswar et al. с другими работами (Lawi et al., 2021; Seabra et al., 2019; Stępień & Skublewska-Paszkowska, 2025), можно увидеть устойчивые тенденции. Так, в исследованиях Lawi et al. GraphQL показывает выигрыш при выборке небольшого подмножества полей, однако при передаче больших массивов данных REST уверенно опережает его по времени отклика. Аналогичную закономерность выявили Seabra et al.: при умеренных нагрузках GraphQL демонстрировал преимущество в производительности, но при увеличении числа параллельных запросов до 3000 и выше REST начинал работать стабильнее и быстрее, поскольку единая точка входа GraphQL превращалась в узкое место.

Работа Stępień & Skublewska-Paszkowska (2025) подтверждает выводы Lawi et al., показывая, что в микросервисных сценариях REST обеспечивал на 51 % меньшую задержку и на 37 % большую пропускную способность, чем GraphQL. При этом GraphQL действительно сокращал размер передаваемых данных, однако это преимущество не компенсировало рост вычислительной нагрузки и снижение устойчивости под нагрузкой.

Учёт данных бенчмарков позволяет сформулировать несколько устойчивых выводов.
Во-первых, gRPC является наиболее производительным протоколом для внутреннего межсервисного взаимодействия, демонстрируя минимальную латентность и высокую пропускную способность в широком диапазоне нагрузок. Работы Niswar et al. показывают, что преимущество gRPC над REST достигает нескольких раз.

Во-вторых, REST остаётся наиболее предсказуемым подходом под высокой нагрузкой и отличается умеренной ресурсоёмкостью, что подтверждается замерами CPU. Более того, в сценариях сложных вложенных данных REST способен конкурировать с gRPC по времени отклика и демонстрирует стабильность, что делает его рациональным выбором для сервисов, рассчитанных на интенсивное чтение данных.

В-третьих, GraphQL обладает высокой гибкостью запросов, но в условиях интенсивной нагрузки он становится наиболее ресурсоёмким и нестабильным протоколом, что ярко подтверждается бенчмарками Niswar et al., где его задержки превышали REST и gRPC в разы. Тем не менее, для клиентского слоя, где важна агрегация данных и минимизация числа запросов, GraphQL остаётся эффективным инструментом.

Таким образом, совокупность экспериментальных данных показывает, что в микросервисной архитектуре оптимальной является гибридная модель: gRPC — для внутренних RPC-взаимодействий, REST — для внешних и партнёрских API с высокой предсказуемостью, GraphQL — как фасадный слой для гибкого клиентского доступа к агрегированным данным. Такое сочетание учитывает реальные бенчмарки и обеспечивает баланс между производительностью, гибкостью и устойчивостью системы под нагрузкой.